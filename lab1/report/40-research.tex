\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item операционная система: Manjaro xfce \cite{ubuntu} Linux \cite{linux} x86\_64;
	\item память: 8 Гб;
	\item мобильный процессор AMD Ryzen™ 7 3700U @ 2.3Гц \cite{intel}.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Демонстрация работы программы}

Программа получает на вход 2 слова и выдает 4 расстояния, соотвествующие расстояниям Дамерау -- Левенштейна, полученным матричным, рекурсивным и рекурсивным с кешем алгоритмами и расстоянию Левенштейна, полученному матричным алгоритмом.

На рисунке \ref{img:example} представлен результат работы программы.

\img{35mm}{example}{Пример работы программы}

\FloatBarrier

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи команды Linux time. Данная команда всегда возвращает значения времени, а именно реальное время, системное и пользовательское процессорное временя текущего процессора, типа float в секундах.

Замеры времени для каждой длины слов проводились 1000000 раз, не считая рекурсивного алгоритма: для длины 6 -- 100000, длины 7 и 8 -- 10000, длины 9 -- 1000. В качестве результата взято среднее время работы алгоритма на данной длине слова.

Оба слова имеют одинаковую длину в символах.

Результаты замеров приведены в таблице \ref{tab:time} (время в мкс).

\begin{table}[h]
	\begin{center}
		\caption{\label{tab:time}Результаты замеров времени}
		\begin{tabular}{|c|c|c|c|c|}
			
			\hline
			Длина & Д.-Л.(матр.)& Д.-Л.(рек с матр.) & Д.-Л.(рек)  & Л.(матр.)  \\
			\hline
			0 & 0.585 & 0.726 & 0.199 & 0.575 \\
			\hline
			1 & 0.770 & 0.876 & 0.235 & 0.768 \\
			\hline
			2 & 0.879 & 1.126 & 0.404 & 0.873 \\
			\hline
			3 & 1.328 & 1.407 & 0.596 & 1.218 \\
			\hline
			4 & 1.385 & 1.763 & 1.766 & 1.273 \\
			\hline
			5 & 1.617 & 2.200 & 7.747 & 1.602 \\
			\hline
			6 & 1.782 & 2.605 & 43.69 & 1.697 \\
			\hline
			7 & 2.476 & 3.273 & 263.9 & 2.449 \\
			\hline
			8 & 2.845 & 3.892 & 1281.0 & 2.651 \\
			\hline
			9 & 3.379 & 4.573 & 7181.0 & 3.155 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\FloatBarrier

На рисунке \ref{img:cas_and_rec} представлены результаты сравнения рекурсивных реализаций алгоритмов поиска расстояния Дамерау -- Левенштейна с использованием кеша и без. На графике видно, что полученные результаты частично накладываются друг на друга (до длины равной 4).

\img{120mm}{cas_and_rec}{Сравнения рекурсивных алгоритмов поиска расстояния Левенштейна с использованием кеша и без}

\FloatBarrier

На рисунке \ref{img:DL_and_L} представлены результаты сравнения итерационных реализаций алгоритмов поиска расстояния Левенштейна и Дамерау -- Левенштейна. На графике видно, что полученные результаты частично накладываются друг на друга (до длины равной 7).

\img{120mm}{DL_and_L}{Сравнения итерационных алгоритмов поиска расстояния Левенштейна и Дамерау-Левенштейна}

\FloatBarrier

На рисунке \ref{img:Cash_Matr} представлены результаты сравнения матричной реализаций алгоритма поиска расстояния Дамерау -- Левенштейна и рекурсивного алгоритма поиска расстояния Дамерау -- Левенштейна с использованием кеша.

\img{120mm}{Cash_Matr}{Сравнения матричного алгоритма поиска расстояния Дамерау -- Левенштейна и рекурсивного алгоритма поиска расстояния Дамерау -- Левенштейна с использованием кеша}

\FloatBarrier
 
\section{Использование памяти}

Алгоритмы нахождения расстояний Левенштейна и Дамерау -- Левенштейна не отличаются друг от друга с точки зрения использования памяти, поэтому достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций данных алгоритмов.

Пусть длина строки S1 - n, длина строки S2 - m, тогда затраты памяти на приведенные выше алгоритмы будут следующими.
\begin{itemize}
	\item Матричный алгоритм поиска расстояния Левенштейна:\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char);
		\item матрица - ((m + 1) * (n + 1)) * sizeof(int);
		\item текущая строка матрицы - (n + 1) * sizeof(int);
		\item длины строк - 2 * sizeof(int);
		\item вспомогательные переменные -  3 * sizeof(int).
	\end{itemize}
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк.

\begin{itemize}
	\item Рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна (для каждого вызова):\begin{itemize}
		\item строки S1, S2 -- (m + n) * sizeof(char);
		\item длины строк -- 2 * sizeof(int);
		\item вспомогательные переменные --  2 * sizeof(int);
		\item размер аргументов функции -- 2 * 24;
		\item размер адреса возврата -- 4.
	\end{itemize}
\end{itemize}
	
Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + (2 * 4 + 2 * 4 + 4 + 2 * 24) * (n + m) = 85m + 85n$.

\begin{itemize}	
	\item Рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна с использованием кеша (для каждого вызова): Для всех вызовов еще память для хранения самой матрицы -  ((m + 1) * (n + 1)) * sizeof(int) \begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char);
		\item длины строк - 2 * sizeof(int);
		\item вспомогательные переменные -  1 * sizeof(int);
		\item размер аргументов функции -- 2 * 24;
		\item ссылка на матрицу - 8 байт;
		\item размер адреса возврата -- 4.
\end{itemize}
\end{itemize}
	
Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + 4 * (m + 1) * (n + 1) + (2 * 4 + 4 + 4 + 2 * 24) * (n + m) = 4mn + 69m + 69n + 4$.
	\begin{itemize}
	\item Матричный алгоритм поиска расстояния Дамерау -- Левенштейна: \begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char);
		\item матрица - ((m + 1) * (n + 1)) * sizeof(int);
		\item длины строк - 2 * sizeof(int);
		\item вспомогательные переменные -  3 * sizeof(int).
	\end{itemize}
\end{itemize}

Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + 4 * (m + 1) * (n + 1) + 6 * 4 = 4mn + 5m + 5n + 28$.

\section*{Вывод}

Рекурсивный алгоритм нахождения расстояния Дамерау -- Левенштейна работает на порядок дольше итеративных реализаций, время его работы увеличивается в геометрической прогрессии. На словах длиной 9 символов, матричная реализация алгоритма нахождения расстояния Дамерау -- Левенштейна превосходит по времени работы рекурсивную на несколько порядков.

Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный и сравним по времени работы с матричными алгоритмами. 

Алгоритм нахождения расстояния Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Дамерау -- Левенштейна. В нём отсутствует дополнительная проверка, позволяющая находить ошибки пользователя, связанные с неверным порядком букв, в связи с чем он работает незначительно быстрее, чем алгоритм нахождения расстояния Дамерау -- Левенштейна.

Но по расходу памяти (при очень больших длинах строк) матричные алгоритмы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
